function [outImage, backgroundLevel] = imSubtractBackgroundVariance(varargin)
% imSubtractBackground takes an input image and subtracts the background from it. The
% image without background is returned as output. This function filters
% the image with a variance filter to detect the background region. The background
% is approximated with a second order polynomial plane. 
% This works particularly well for images with an uneven background intensity like
% phase-contrast images.
%
% SYNOPSIS       [outImage, backgroundLevel] = imSubtractBackgroundVariance(varargin)
%
% INPUT          inputImage: the original greylevel image including background
%                greyMax   : bitdepth of the image
%                kernelSize: variance filter kernel size
%
% OUTPUT         outImage: the original image with the estimated background subtracted
%                backgroundLevel: the average level of the background plane
%
% DEPENDENCIES   imSubtractBackground uses { nothing }
%                                  
%                imSubtractBackground is used by { ptGetProcessedImage }
%
% Revision History
% Name                  Date            Comment
% --------------------- --------        --------------------------------------------------------
% Andre Kerstens        Apr 04          Initial release


% Test the number of input variables
if nargin < 3
   error('The input image, the maximum grey level (eg 4095 for a 12 bit image) and the kernel size (15 is a good value) have to be provided. See help ptGetProcessedImage.');
end

% Get the input variables
inputImage = varargin{1};
greyMax    = varargin{2};
kernelSize = varargin{3};

% Calculate the variance image
varImage = imVarianceImage (inputImage, kernelSize);

% Calculate the optimum threshold to segment this image
[threshold, J] = imMinimumThreshold (varImage, greyMax);

% Get the binary image where all of the background is 1
binImage = ~im2bw (varImage, threshold);

% Show only the background pixels in the original image (by multiplying with 
% the binary image). And then fetch the index of these specific pixels
newImage = inputImage .* binImage;
backOnlyImage = newImage (find (binImage));

% Get the x and y coordinates of these pixels
[x,y] = find (binImage);

% Now we start to solve the equation I(x,y) = f(x,y) where f(x,y) is ax^2+bxy+cy^2+d
% For this we need to create a matrix A = [x^2, xy, y^2, 1] to solve the coeff. 
% a, b, c and d (1 can be generated by ones(size(x),1)). The equation can then be solved
% by A \ backOnlyImage
one = ones(size(x,1),1);
A = [x.^2, x.*y, y.^2, one];
coeff = A \ backOnlyImage;

% Now calculate the background image using the estimated coefficients (we need
% the size of the whole input image this time so that we can subtract later.
[xi,yi] = find (inputImage);
backgroundImage = coeff(1).*(xi.^2) + coeff(2).*(xi.*yi) + coeff(3).*(yi.^2) + coeff(4);
%figure, mesh (reshape(backgroundImage,size(inputImage)));

% The average background level is approx. equal to the constant in the equation
backgroundLevel = coeff(4);

% Now we only have to subtract the background from the image and we're done
outImage = inputImage - reshape(backgroundImage,size(inputImage));

% Let's normalize the image back to [0..1] again
imageMinimum = min (min (outImage));
imageMaximum = max (max (outImage));
outImage = (outImage - imageMinimum) / (imageMaximum - imageMinimum);
